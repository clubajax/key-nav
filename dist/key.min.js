!function(define) {
define([ "on" ], function(on) {
"use strict";
function keys(listNode, options) {
function highlight(node) {
return highlighted && highlighted.removeAttribute("highlighted"), node && (highlighted = node, 
highlighted.setAttribute("highlighted", "true")), highlighted;
}
function select(node) {
return selected && selected.removeAttribute("selected"), node && (selected = node, 
selected.setAttribute("selected", "true")), selected;
}
options = options || {};
var observer, searchStringTimer, controller = {
setSelected: function(node) {
highlight(select(node)), on.fire(listNode, "key-select", {
value: selected
});
},
getSelected: function() {
return selected;
},
destroy: function() {
select(), highlight(), this.handles.forEach(function(h) {
h.remove();
}), observer && observer.disconnect();
}
}, searchString = "", searchStringTime = options.searchTime || 1e3, children = listNode.children, selected = select(getSelected(children)), highlighted = highlight(selected), nodeType = highlighted.localName;
return on.fire(listNode, "key-highlight", {
value: highlighted
}), on.fire(listNode, "key-select", {
value: highlighted
}), controller.handles = [ on(listNode, "mouseover", nodeType, function(e, node) {
highlight(node), on.fire(listNode, "key-highlight", {
value: highlighted
});
}), on(listNode, "mouseout", function(e) {
highlight(null), on.fire(listNode, "key-highlight", {
value: null
});
}), on(listNode, "blur", function(e) {
highlight(null), on.fire(listNode, "key-highlight", {
value: null
});
}), on(listNode, "click", nodeType, function(e, node) {
highlight(node), select(node), on.fire(listNode, "key-select", {
value: selected
});
}), on(listNode, "keydown", function(e) {
if (!e.defaultPrevented) {
switch (e.key) {
case "Enter":
select(highlighted), on.fire(listNode, "key-select", {
value: selected
});
break;

case "Escape":
console.log("esc");
break;

case "ArrowRight":
case "ArrowDown":
highlight(getNode(children, highlighted || selected, "down")), on.fire(listNode, "key-highlight", {
value: highlighted
});
break;

case "ArrowLeft":
case "ArrowUp":
highlight(getNode(children, highlighted || selected, "up")), on.fire(listNode, "key-highlight", {
value: highlighted
});
break;

default:
if (on.isAlphaNumeric(e.key)) {
searchString += e.key;
var searchNode = searchHtmlContent(children, searchString);
searchNode && highlight(select(searchNode));
break;
}
return;
}
return clearTimeout(searchStringTimer), searchStringTimer = setTimeout(function() {
searchString = "";
}, searchStringTime), e.preventDefault(), !1;
}
}) ], options.roles && (addRoles(listNode), "undefined" != typeof MutationObserver && (observer = new MutationObserver(function(mutations) {
mutations.forEach(function(event) {
console.log("mutation", event), event.addedNodes.length && addRoles(listNode);
});
}), observer.observe(listNode, {
childList: !0
}))), controller;
}
function isSelected(node) {
return !!node && (node.selected || node.getAttribute("selected"));
}
function getSelected(children) {
for (var i = 0; i < children.length; i++) if (isSelected(children[i])) return children[i];
return children[0];
}
function getNext(children, index) {
for (var norecurse = children.length + 2, node = children[index]; node; ) {
if (index++, index > children.length - 1) index = -1; else if (children[index] && !children[index].parentNode.disabled) {
node = children[index];
break;
}
if (norecurse-- < 0) {
console.log("RECURSE");
break;
}
}
return node;
}
function getPrev(children, index) {
for (var norecurse = children.length + 2, node = children[index]; node; ) {
if (index--, index < 0) index = children.length; else if (children[index] && !children[index].parentNode.disabled) {
node = children[index];
break;
}
if (norecurse-- < 0) {
console.log("RECURSE");
break;
}
}
return node;
}
function getNode(children, highlighted, dir) {
var i;
for (i = 0; i < children.length && children[i] !== highlighted; i++) ;
return "down" === dir ? getNext(children, i) : "up" === dir ? getPrev(children, i) : void 0;
}
function searchHtmlContent(children, str) {
for (var i = 0; i < children.length; i++) if (0 === children[i].innerHTML.indexOf(str)) return children[i];
return null;
}
function addRoles(node) {
for (var i = 0; i < node.children.length; i++) node.children[i].setAttribute("role", "listitem");
node.setAttribute("role", "listbox");
}
if ("function" == typeof customLoader) customLoader(keys, "keys"); else if ("undefined" != typeof window) window.keys = keys; else {
if ("undefined" == typeof module) return keys;
module.exports = keys;
}
});
}("function" == typeof define && define.amd ? define : function(ids, factory) {
var deps = ids.map(function(id) {
return "function" == typeof require ? require(id) : window[id];
});
"undefined" != typeof module ? module.exports = factory.apply(null, deps) : factory.apply(null, deps);
});