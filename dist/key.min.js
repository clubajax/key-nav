!function(root, factory) {
"function" == typeof define && define.amd ? define([ "on" ], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("on")) : (root.returnExports = factory(), 
root.keys = factory(root.on));
}(this, function(on) {
"use strict";
function keys(listNode, options) {
function highlight(node) {
return node = fromArray(node), highlighted && highlighted.removeAttribute("highlighted"), 
node && (highlighted = node, highlighted.setAttribute("highlighted", "true")), highlighted;
}
function select(node) {
return options.multiple ? selected ? shift || meta ? shift && node ? selected = findShiftNodes(children, selected, node) : meta && node && (selected ? selected.push(node) : selected = [ node ], 
node.setAttribute("selected", "true")) : (selected.forEach(function(sel) {
sel.removeAttribute("selected");
}), node && (selected = [ node ], node.setAttribute("selected", "true"))) : selected = [ node ] : (selected && selected.removeAttribute("selected"), 
node && (selected = node, selected.setAttribute("selected", "true"))), selected;
}
options = options || {};
var observer, searchStringTimer, controller = {
setSelected: function(node) {
highlight(select(node)), on.fire(listNode, "key-select", {
value: selected
});
},
getSelected: function() {
return selected;
},
destroy: function() {
select(), highlight(), this.handles.forEach(function(h) {
h.remove();
}), observer && observer.disconnect();
}
}, tableMode = "table" === listNode.localName, canSelectNone = void 0 === options.canSelectNone || options.canSelectNone, shift = !1, meta = !1, searchString = "", searchStringTime = options.searchTime || 1e3, children = tableMode ? listNode.querySelectorAll("td") : listNode.children, selected = select(getSelected(children, options.noDefault)), highlighted = highlight(fromArray(selected)), nodeType = (highlighted || children[0]).localName;
return on.fire(listNode, "key-highlight", {
value: highlighted
}), on.fire(listNode, "key-select", {
value: highlighted
}), controller.handles = [ on(listNode, "mouseover", nodeType, function(e, node) {
highlight(node), on.fire(listNode, "key-highlight", {
value: highlighted
});
}), on(listNode, "mouseout", function(e) {
highlight(null), on.fire(listNode, "key-highlight", {
value: null
});
}), on(listNode, "blur", function(e) {
highlight(null), on.fire(listNode, "key-highlight", {
value: null
});
}), on(listNode, "click", nodeType, function(e, node) {
highlight(node), select(node), on.fire(listNode, "key-select", {
value: selected
});
}), on(document, "keyup", function(e) {
e.defaultPrevented || (shift = !1, meta = !1);
}), on(document, "keydown", function(e) {
if (!e.defaultPrevented) switch (e.key) {
case "Meta":
case "Control":
case "Command":
meta = !0;
break;

case "Shift":
shift = !0;
}
}), on(listNode, "keydown", function(e) {
if (!e.defaultPrevented) {
switch (e.key) {
case "Enter":
select(highlighted), on.fire(listNode, "key-select", {
value: selected
});
break;

case "Escape":
canSelectNone && select(null);
break;

case "ArrowDown":
if (tableMode) {
console.log("table!"), highlight(getCell(children, highlighted || selected, "down")), 
on.fire(listNode, "key-highlight", {
value: highlighted
});
break;
}

case "ArrowRight":
highlight(getNode(children, highlighted || selected, "down")), on.fire(listNode, "key-highlight", {
value: highlighted
});
break;

case "ArrowUp":
if (tableMode) {
console.log("table!"), highlight(getCell(children, highlighted || selected, "up")), 
on.fire(listNode, "key-highlight", {
value: highlighted
});
break;
}

case "ArrowLeft":
highlight(getNode(children, highlighted || selected, "up")), on.fire(listNode, "key-highlight", {
value: highlighted
});
break;

default:
if (on.isAlphaNumeric(e.key)) {
if ("r" == e.key && meta) return !0;
searchString += e.key;
var searchNode = searchHtmlContent(children, searchString);
searchNode && highlight(select(searchNode)), clearTimeout(searchStringTimer), searchStringTimer = setTimeout(function() {
searchString = "";
}, searchStringTime);
break;
}
return;
}
return e.preventDefault(), !1;
}
}) ], options.roles && (addRoles(listNode), "undefined" != typeof MutationObserver && (observer = new MutationObserver(function(mutations) {
mutations.forEach(function(event) {
event.addedNodes.length && addRoles(listNode);
});
}), observer.observe(listNode, {
childList: !0
}))), controller;
}
function isSelected(node) {
return !!node && (node.selected || node.getAttribute("selected"));
}
function getSelected(children, noDefault) {
for (var i = 0; i < children.length; i++) if (isSelected(children[i])) return children[i];
return noDefault ? null : children[0];
}
function getNext(children, index) {
for (var norecurse = children.length + 2, node = children[index]; node; ) {
if (index++, index > children.length - 1) index = -1; else if (children[index] && !children[index].parentNode.disabled) {
node = children[index];
break;
}
if (norecurse-- < 0) {
console.log("RECURSE");
break;
}
}
return node;
}
function getPrev(children, index) {
for (var norecurse = children.length + 2, node = children[index]; node; ) {
if (index--, index < 0) index = children.length; else if (children[index] && !children[index].parentNode.disabled) {
node = children[index];
break;
}
if (norecurse-- < 0) {
console.log("RECURSE");
break;
}
}
return node;
}
function getNode(children, highlighted, dir) {
var i;
for (i = 0; i < children.length && children[i] !== highlighted; i++) ;
return "down" === dir ? getNext(children, i) : "up" === dir ? getPrev(children, i) : void 0;
}
function getCell(children, highlighted, dir) {
var cellIndex = getIndex(highlighted), row = highlighted.parentNode, rowIndex = getIndex(row), rowAmount = row.parentNode.rows.length;
return "down" === dir ? rowIndex + 1 < rowAmount ? row.parentNode.rows[rowIndex + 1].cells[cellIndex] : row.parentNode.rows[0].cells[cellIndex] : "up" === dir ? rowIndex > 0 ? row.parentNode.rows[rowIndex - 1].cells[cellIndex] : row.parentNode.rows[rowAmount - 1].cells[cellIndex] : void 0;
}
function getIndex(el) {
var i, p = el.parentNode;
for (i = 0; i < p.children.length; i++) if (p.children[i] === el) return i;
return null;
}
function searchHtmlContent(children, str) {
for (var i = 0; i < children.length; i++) if (0 === children[i].innerHTML.indexOf(str)) return children[i];
return null;
}
function findShiftNodes(children, selected, node) {
var i, a, b, c, newIndex, lastIndex, lastNode = selected[selected.length - 1], selection = [];
for (selected.forEach(function(sel) {
sel.removeAttribute("selected");
}), i = 0; i < children.length; i++) c = children[i], c === node ? newIndex = i : c === lastNode && (lastIndex = i);
for (newIndex < lastIndex ? (a = newIndex, b = lastIndex) : (b = newIndex, a = lastIndex); a <= b; ) children[a].setAttribute("selected", ""), 
selection.push(children[a]), a++;
return selection;
}
function addRoles(node) {
for (var i = 0; i < node.children.length; i++) node.children[i].setAttribute("role", "listitem");
node.setAttribute("role", "listbox");
}
function fromArray(thing) {
return Array.isArray(thing) ? thing[0] : thing;
}
return keys;
});